"C++11"

let cacq = ACQ | (SC & (R | F)) | ACQ_REL | (F & con)
let crel = REL | (SC & (W | F)) | ACQ_REL
let ccon = R & CONS

let dd = (data | addr)+

let fsb = [F] ; po
let sbf = po ; [F]

(* release_acquire_fenced_synchronizes_with,
   hypothetical_release_sequence_set,
   release_sequence_set *)

(* OLD: let rs = [crel] ; fsb? ; [A & W] ;
     (((co ; [rmw]) | coi) & ~(coe ; [!rmw] ; co))? *)
let rs_prime = int | (_ * (R & W))
let rs = co & rs_prime \ ((co \ rs_prime) ; co)
               
(* OLD: let swra = ext (rs ; rf ; [A] ; sbf? ; [cacq]) *)
let swra = ext & ([crel] ; fsb? ; [A & W] ; rs? ; rf ; [R & A] ; sbf? ; [cacq])
                                     
//let swul = ext & ([ul] ; lo ; [lk])
//let pp_asw = asw \ (asw ; po)
//let sw = pp_asw | swul | swra
let sw = swra

(* with_consume_cad_set,
   dependency_ordered_before *)
let cad = ((rf & po) | dd)+
let dob = (ext & ([W & crel] ; fsb? ; [A & W] ; rs?; rf; [ccon])); cad?

(* happens_before,
   inter_thread_happens_before,
   consistent_hb *)
let ithbr = sw | dob | (sw ; po)
let ithb = (ithbr | (po ; ithbr))+
let hb = po | ithb
acyclic hb as Hb

(* coherent_memory_use *)
let hbl = hb & loc

irreflexive ((rf^-1)? ; co ; rf? ; hb) as Coh

(* visible_side_effect_set *)
let vis = ([W] ; hbl ; [R])
          & ~(hbl; [W]; hbl)

(* consistent_atomic_rf *)
irreflexive (rf ; hb) as Rf
          
(* consistent_non_atomic_rf  *)
empty ((rf ; [nonatomicloc]) \ vis) as NaRf

irreflexive (rf | (co ; co ; rf^-1) | (co ; rf)) as Rmw


(* locks_only_consistent_lo *)
//irreflexive (lo ; hb) as Lo1

(* locks_only_consistent_locks *)
//irreflexive ([ls] ; lo^-1 ; [ls] ;
//  ~(lo ; [ul] ; lo)) as Lo2

(* data_races *)
let cnf = ((W * _) | (_ * W)) & loc
let dr = ext & (cnf \ hb \ (hb^-1) \ (A * A))

(* unsequenced_races *)
let ur = int & ((W * M) | (M * W)) &
         loc & ~[_] & ~(po+) & ~((po+)^-1)

(* locks_only_good_mutex_use,
   locks_only_bad_mutexes *)
//let bl = ([ls]; (po & lo); [lk])
//         & ~(lo; [ul]; lo)

//let losbwoul = (po & lo & ~(lo; [ul]; lo))
//let lu = [ul] &
//  ~([ul] ; losbwoul^-1 ; [ls] ; losbwoul ; [ul])

let r1 = hb
let r2 = fsb? ; co ; sbf?
let r3 = rf^-1; [sc] ; co
let r4 = rf^-1 ; hbl ; [W]
let r5 = fsb ; fr
let r6 = fr ; sbf
let r7 = fsb ; fr ; sbf

let scp = r1|r2|r3|r4|r5|r6|r7

acyclic (((sc * sc) & scp) \ [_]) as Spartial

//undefined_unless empty dr as Dr 
//undefined_unless empty ur as unsequencedRace 
//undefined_unless empty bl as badLock
//undefined_unless empty lu as badUnlock

